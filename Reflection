Reflection
behaviours & potential problems：
最终的效果是符合预期的——随着病人不断来到，护士会随机地分配给新来的病人；一旦分配，她们会从始至终地协助同一个病人导诊、治疗或出院，不同的线程在关键节点上竞争执行权——这使得事情都是随机的发生（当然，在合法的框架下），这包括护士争夺病人、病人在未定义廊道中争夺进入房间。同时，在条件不满足时，线程等待被通知。
在参数合理的前提下，系统有条不紊，但一旦加快某些过程，例如，产生病人的速度快过ED诊疗流程时，患者编号会跳号；又如，缩减orderlies编制以至于与护士数量相对应的满编需求时，会有较大机会使得流程卡住，尤其是当orderlies被排队占据而治疗完毕的患者无人转运时，我们就只能看到专家不断进出诊室而其他人凝滞住了。
而当orderlies足够，又通常最终陷入过多的组在等待、而仅剩下的一组orderlies负责不断转运新患者。
key design decisions or problems：
我的流程基本是由nurse驱动的，且房间的出入采取接口化，同时寻址委托给患者类，下一步要去哪里由患者类规定，这允许了拓展性，但使得Nurse类的run方法过于臃肿。
在开发中我遇到若干次“一个锁不够”的问题，体现为，不但要锁方法，还要锁自身对象，比如解决房间重复进入违反容量限制的问题。最终enter（）方法都呈现为方法和对象的双重锁定，这并不优雅。
insights：
这些问题一方面是系统性的、机制性的，也即：人手的确不足，等待队列消耗完了勤务人员，后面的流程不能正确清空、前面的人就不能继续。另一方面，通过synchronized和wait-notify模式来管理共享资源的做法对心智开销甚大，一旦系统设计不够扁平，意料之外的死锁就有可能出现。
