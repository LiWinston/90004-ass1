Reflection:
Behaviors & Potential Problems:
The final outcome meets expectations - as patients arrive, nurses are randomly assigned to new arrivals. Once assigned, they assist the same patient throughout triage, treatment, or discharge, with different threads competing for execution rights at critical points. This randomness, within legal bounds, includes nurses vying for patients and patients competing to enter rooms in undefined corridors. Meanwhile, threads wait to be notified when conditions are not met. Under reasonable parameters, the system operates smoothly. However, accelerating certain processes, such as patient arrival rates exceeding ED treatment pace, can lead to patient number skipping. Similarly, reducing the number of orderlies to below nurses’ demand can significantly increase the chance of workflow stalling, especially when orderlies are occupied in queues and patients awaiting transport after treatment are left unattended, leading to observed stagnation except for the specialist constantly entering and exiting. With sufficient orderlies, it often results in too many groups waiting, with only one group responsible for continuous patient transfers.

Key Design Decisions or Problems:
My workflow is primarily driven by nurses, with room access interface-based and addressing delegated to patient classes, allowing for scalability but resulting in the Nurse class's run method becoming overly cumbersome. During development, I encountered several instances of "one lock not enough" issues, manifested as needing to lock methods and the object itself, such as resolving the problem of rooms being repeatedly entered in violation of capacity limits. Ultimately, the enter() method presents as a dual locking of method and object, which is not elegant.
Another problem encountered was "Whom to be locked." My decision was that when two threads interact with each other, it's best for each thread to acquire the lock of the other, or at least acquire the lock of the party at risk of performing a series of non-atomic operations. When threads interact with resource objects, priority is given to locking the resource.
Regarding variables, if unsure whether they are prone to stale caching, it's easier to declare them as volatile.
As for the movement process between rooms, I decided to decouple departure from arrival. Departures occur when conditions are met, but arrival is contingent upon acquiring the lock of the destination. Otherwise, the thread waits. This approach provides a more realistic simulation of concurrency but increases the likelihood of queuing and waiting traps.

Insights:
These issues are both systemic and mechanistic, indicating a genuine shortage of manpower where the depletion of the waiting queue exhausts personnel, preventing subsequent processes from clearing correctly and causing preceding individuals to stall. Moreover, the approach of managing shared resources using synchronized and wait-notify patterns incurs significant mental overhead. If the system design is not sufficiently flat, unexpected deadlocks may occur. Locks can only guarantee the atomicity of the code block, but when the logic becomes complex, inevitably, new competitions arise within the block—nested situations occur. People must constantly simulate in their minds and decide: "When should I appropriately release the lock and notify?"
